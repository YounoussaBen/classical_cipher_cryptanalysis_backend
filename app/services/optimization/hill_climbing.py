import random
import string
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Callable, TypeVar

T = TypeVar("T")


@dataclass
class OptimizationResult:
    """Result of an optimization run."""

    best_key: Any
    best_score: float
    iterations: int
    improved: bool


class HillClimber(ABC):
    """
    Abstract base for hill climbing optimization.

    Hill climbing is a local search algorithm that iteratively moves
    to better neighbors until no improvement is found.
    """

    def __init__(
        self,
        max_iterations: int = 10000,
        restarts: int = 5,
    ):
        """
        Initialize hill climber.

        Args:
            max_iterations: Maximum iterations per restart
            restarts: Number of random restarts
        """
        self.max_iterations = max_iterations
        self.restarts = restarts

    @abstractmethod
    def random_key(self) -> T:
        """Generate a random starting key."""
        pass

    @abstractmethod
    def get_neighbors(self, key: T) -> list[T]:
        """Get neighboring keys (small modifications)."""
        pass

    @abstractmethod
    def evaluate(self, key: T) -> float:
        """Evaluate a key (higher is better)."""
        pass

    def optimize(self) -> OptimizationResult:
        """
        Run hill climbing optimization.

        Returns:
            OptimizationResult with best key found
        """
        global_best_key = None
        global_best_score = float("-inf")
        total_iterations = 0

        for _ in range(self.restarts):
            key = self.random_key()
            score = self.evaluate(key)
            iterations = 0

            improved = True
            while improved and iterations < self.max_iterations:
                improved = False
                neighbors = self.get_neighbors(key)

                for neighbor in neighbors:
                    neighbor_score = self.evaluate(neighbor)
                    iterations += 1

                    if neighbor_score > score:
                        key = neighbor
                        score = neighbor_score
                        improved = True
                        break  # First improvement

            total_iterations += iterations

            if score > global_best_score:
                global_best_score = score
                global_best_key = key

        return OptimizationResult(
            best_key=global_best_key,
            best_score=global_best_score,
            iterations=total_iterations,
            improved=global_best_score > float("-inf"),
        )


class SubstitutionHillClimber(HillClimber):
    """
    Hill climber for simple substitution cipher.

    The key is a permutation of the alphabet.
    Neighbors are generated by swapping pairs of letters.
    """

    ALPHABET = string.ascii_uppercase

    def __init__(
        self,
        ciphertext: str,
        fitness_fn: Callable[[str], float],
        max_iterations: int = 10000,
        restarts: int = 10,
    ):
        """
        Initialize substitution hill climber.

        Args:
            ciphertext: The ciphertext to decrypt
            fitness_fn: Function to score plaintext (higher is better)
            max_iterations: Max iterations per restart
            restarts: Number of random restarts
        """
        super().__init__(max_iterations, restarts)
        self.ciphertext = ciphertext.upper()
        self.fitness_fn = fitness_fn

    def random_key(self) -> str:
        """Generate random permutation of alphabet."""
        letters = list(self.ALPHABET)
        random.shuffle(letters)
        return "".join(letters)

    def get_neighbors(self, key: str) -> list[str]:
        """Generate neighbors by swapping letter pairs."""
        neighbors = []
        key_list = list(key)

        # All possible swaps
        for i in range(len(key_list)):
            for j in range(i + 1, len(key_list)):
                neighbor = key_list.copy()
                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
                neighbors.append("".join(neighbor))

        random.shuffle(neighbors)
        return neighbors

    def evaluate(self, key: str) -> float:
        """Decrypt with key and evaluate fitness."""
        plaintext = self._decrypt(key)
        return self.fitness_fn(plaintext)

    def _decrypt(self, key: str) -> str:
        """Decrypt ciphertext with substitution key."""
        # Key maps alphabet to substitution
        # To decrypt, we need the inverse
        inverse = {key[i]: self.ALPHABET[i] for i in range(26)}

        result = []
        for char in self.ciphertext:
            if char in inverse:
                result.append(inverse[char])
            else:
                result.append(char)

        return "".join(result)


class SimulatedAnnealing:
    """
    Simulated annealing optimization.

    Similar to hill climbing but occasionally accepts worse solutions
    to escape local optima. The probability of accepting worse solutions
    decreases over time (cooling schedule).
    """

    def __init__(
        self,
        initial_temp: float = 20.0,
        cooling_rate: float = 0.001,
        min_temp: float = 0.1,
    ):
        """
        Initialize simulated annealing.

        Args:
            initial_temp: Starting temperature
            cooling_rate: Rate of cooling (multiplied each step)
            min_temp: Stop when temperature reaches this
        """
        self.initial_temp = initial_temp
        self.cooling_rate = cooling_rate
        self.min_temp = min_temp

    def optimize(
        self,
        initial_key: Any,
        get_neighbor: Callable[[Any], Any],
        evaluate: Callable[[Any], float],
    ) -> OptimizationResult:
        """
        Run simulated annealing optimization.

        Args:
            initial_key: Starting key
            get_neighbor: Function to generate a random neighbor
            evaluate: Fitness function (higher is better)

        Returns:
            OptimizationResult with best key found
        """
        current_key = initial_key
        current_score = evaluate(current_key)

        best_key = current_key
        best_score = current_score

        temp = self.initial_temp
        iterations = 0

        while temp > self.min_temp:
            neighbor_key = get_neighbor(current_key)
            neighbor_score = evaluate(neighbor_key)
            iterations += 1

            delta = neighbor_score - current_score

            # Accept if better, or probabilistically if worse
            if delta > 0:
                current_key = neighbor_key
                current_score = neighbor_score
            else:
                acceptance_prob = pow(2.71828, delta / temp)
                if random.random() < acceptance_prob:
                    current_key = neighbor_key
                    current_score = neighbor_score

            # Update best
            if current_score > best_score:
                best_key = current_key
                best_score = current_score

            # Cool down
            temp *= (1 - self.cooling_rate)

        return OptimizationResult(
            best_key=best_key,
            best_score=best_score,
            iterations=iterations,
            improved=best_score > evaluate(initial_key),
        )
